import { redis, roomStore, roomUserStore, sessionStore } from '../stores/stores';
import * as Socket from '../controllers/socket';

import { createServer } from 'http';
import { Server } from 'socket.io';
import { io as Client, Socket as ClientSocket } from 'socket.io-client';
import { AddressInfo } from 'net';
import { MangaSocket, RoomResponse } from '../types';
import { socketMiddleware } from '../controllers/socketMiddleware';

jest.setTimeout(30000);

describe('updated server socket', () => {
  let io: Server, serverSocket: MangaSocket, clientSocket: ClientSocket, clientSocket2: ClientSocket, PORT: number;

  afterAll(() => {
    redis.quit();
  });

  describe('room users on create room', () => {
    let roomId: string;

    beforeAll((done) => {
      redis.flushall();

      const httpServer = createServer();
      io = new Server(httpServer);
      io.use(socketMiddleware);

      httpServer.listen(() => {
        const { onLogin } = Socket.default(io);
        const { port } = httpServer.address() as AddressInfo;
        PORT = port;
        io.on('connection', (socket) => {
          serverSocket = socket;
          serverSocket.on('SESSION', onLogin);
        });

        clientSocket = Client(
          `http://localhost:${port}`,
          {
            auth: {
              username: 'robie',
              sessionId: '',
              roomId: ''
            },
            forceNew: true
          }
        );

        clientSocket.on('connect', () => {
          clientSocket.emit('SESSION', () => {
            done();
          });
        });
      });

    });

    afterAll(() => {
      io.close();
      clientSocket.close();
      clientSocket2.close();
    });

    test('client creates room', (done) => {
      const { createRoom } = Socket.default(io);
      serverSocket.on('CREATE_ROOM', createRoom);

      // serversocket.sessionid is session id generated by server that is sent to client
      clientSocket.emit('CREATE_ROOM', serverSocket.sessionId, (cb: RoomResponse) => {
        expect(cb.success).toBe(true);
        expect(cb.roomId).toHaveLength(6);
        roomId = cb.roomId;
        done();
      });
    });

    test('users on create', (done) => {
      const { newRoom } = Socket.default(io);
      serverSocket.on('NEW_ROOM', newRoom);

      clientSocket.emit('NEW_ROOM', roomId, (cb: string[]) => {
        expect(cb).toContain('robie');
        expect(cb).toHaveLength(1);
        done();
      });
    });

    test('another user can connect', (done) => {
      // hack... maybe fix in future
      // i did this bc idk if serversocket.sessionid will be different based on the different clients
      sessionStore.saveSession('123', {
        username: 'another robie',
        roomId: ''
      });

      clientSocket2 = Client(
        `http://localhost:${PORT}`,
        {
          auth: {
            username: 'another robie',
            sessionId: '123',
            roomId: ''
          },
          forceNew: true
        }
      );

      clientSocket2.on('connect', () => {
        clientSocket2.emit('SESSION', () => {
          done();
        });
      });
    });

    test('user joins room', (done) => {
      const { joinRoom } = Socket.default(io);
      serverSocket.on('JOIN_ROOM', joinRoom);

      clientSocket2.emit('JOIN_ROOM', '123', roomId, (cb: RoomResponse) => {
        expect(cb.success).toBe(true);
        expect(cb.roomId).toBe(roomId);
        done();
      });

    });

    test('room users on join room', (done) => {
      const { newRoom } = Socket.default(io);
      serverSocket.on('NEW_ROOM', newRoom);

      clientSocket2.emit('NEW_ROOM', roomId, (cb: string[]) => {
        expect(cb).toHaveLength(2);
        expect(cb).toContain('robie');
        expect(cb).toContain('another robie');
        done();
      });
    });

  });
})
